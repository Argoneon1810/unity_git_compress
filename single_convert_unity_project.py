#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
단일 유니티 프로젝트를 Git repository로 초기화하고 클론하는 스크립트

입력받은 프로젝트 디렉터리에 대해:
1) .gitignore 설정 및 Git 초기화
2) 최종적으로 Git Clone하여 출력 디렉터리에 복제

Usage:
  python convert_unity_project.py --project_path "C:/UnityProjects/MyProject" --output_path "C:/Output"

※ 주의사항
- Git이 설치되어 있어야 하며, PATH에 등록되어 있어야 합니다.
"""

import sys
import argparse
import subprocess
from pathlib import Path
from typing import Tuple
import logging


# ============================================================================
# 로깅 설정
# ============================================================================

def setup_logging() -> logging.Logger:
    """로깅 설정"""
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.INFO)
    
    handler = logging.StreamHandler()
    formatter = logging.Formatter('[%(levelname)s] %(message)s')
    handler.setFormatter(formatter)
    
    logger.addHandler(handler)
    return logger


logger = setup_logging()


# ============================================================================
# 상수
# ============================================================================

UNITY_GITIGNORE = r"""# This .gitignore file should be placed at the root of your Unity project directory
#
# Get latest from [https://github.com/github/gitignore/blob/main/Unity.gitignore](https://github.com/github/gitignore/blob/main/Unity.gitignore)
#
.utmp/
/[Ll]ibrary/
/[Tt]emp/
/[Oo]bj/
/[Bb]uild/
/[Bb]uilds/
/[Ll]ogs/
/[Uu]ser[Ss]ettings/
*.log

# By default unity supports Blender asset imports, *.blend1 blender files do not need to be commited to version control.
*.blend1
*.blend1.meta

# MemoryCaptures can get excessive in size.
# They also could contain extremely sensitive data
/[Mm]emoryCaptures/

# Recordings can get excessive in size
/[Rr]ecordings/

# Uncomment this line if you wish to ignore the asset store tools plugin
# /[Aa]ssets/AssetStoreTools*

# Autogenerated Jetbrains Rider plugin
/[Aa]ssets/Plugins/Editor/JetBrains*
# Jetbrains Rider personal-layer settings
*.DotSettings.user

# Visual Studio cache directory
.vs/

# Gradle cache directory
.gradle/

# Autogenerated VS/MD/Consulo solution and project files
ExportedObj/
.consulo/
*.csproj
*.unityproj
*.sln
*.suo
*.tmp
*.user
*.userprefs
*.pidb
*.booproj
*.svd
*.pdb
*.mdb
*.opendb
*.VC.db

# Unity3D generated meta files
*.pidb.meta
*.pdb.meta
*.mdb.meta

# Unity3D generated file on crash reports
sysinfo.txt

# Mono auto generated files
mono_crash.*

# Builds
*.apk
*.aab
*.unitypackage
*.unitypackage.meta
*.app

# Crashlytics generated file
crashlytics-build.properties

# TestRunner generated files
InitTestScene*.unity*

# Addressables default ignores, before user customizations
/ServerData
/[Aa]ssets/StreamingAssets/aa*
/[Aa]ssets/AddressableAssetsData/link.xml*
/[Aa]ssets/Addressables_Temp*
/[Aa]ssets/AddressableAssetsData/*/*.bin*

# Visual Scripting auto-generated files
/[Aa]ssets/Unity.VisualScripting.Generated/VisualScripting.Flow/UnitOptions.db
/[Aa]ssets/Unity.VisualScripting.Generated/VisualScripting.Flow/UnitOptions.db.meta
/[Aa]ssets/Unity.VisualScripting.Generated/VisualScripting.Core/Property Providers
/[Aa]ssets/Unity.VisualScripting.Generated/VisualScripting.Core/Property Providers.meta

# Auto-generated scenes by play mode tests
/[Aa]ssets/[Ii]nit[Tt]est[Ss]cene*.unity*
"""


# ============================================================================
# 인자 파싱
# ============================================================================

def parse_args() -> argparse.Namespace:
    """커맨드 라인 인자 파싱"""
    parser = argparse.ArgumentParser(
        description="Convert a single Unity project with Git initialization and .gitignore, then clone it."
    )
    parser.add_argument(
        "--project_path",
        required=True,
        help="Path to the Unity project directory to be converted"
    )
    parser.add_argument(
        "--output_path",
        required=True,
        help="Path where the cloned project will be saved"
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Force clone even if output path already exists (will remove existing directory)"
    )
    return parser.parse_args()


# ============================================================================
# 유틸리티 함수
# ============================================================================

def is_git_repo(directory: Path) -> bool:
    """
    디렉터리가 Git repository인지 확인
    
    Args:
        directory: 확인할 디렉터리 경로
        
    Returns:
        Git repository이면 True, 아니면 False
    """
    git_dir = directory / ".git"
    return git_dir.is_dir()


def has_gitignore(directory: Path) -> bool:
    """
    디렉터리가 .gitignore 파일을 가지고 있는지 확인
    
    Args:
        directory: 확인할 디렉터리 경로
        
    Returns:
        .gitignore이 있으면 True, 아니면 False
    """
    gitignore_path = directory / ".gitignore"
    return gitignore_path.is_file()


def run_git_command(git_args: list, cwd: Path) -> Tuple[bool, str]:
    """
    Git 명령어 실행
    
    Args:
        git_args: git 서브명령어와 인자 리스트
        cwd: git 명령어를 실행할 디렉터리
        
    Returns:
        (성공 여부, 에러 메시지)
    """
    try:
        result = subprocess.run(
            ["git", "-C", str(cwd)] + git_args,
            check=True,
            capture_output=True,
            text=True
        )
        return True, result.stdout
    except subprocess.CalledProcessError as e:
        error_msg = e.stderr if e.stderr else str(e)
        return False, error_msg


def init_and_commit_project(project_path: Path) -> Tuple[bool, str]:
    """
    프로젝트를 Git repository로 초기화하고 .gitignore 추가
    
    Args:
        project_path: 프로젝트 디렉터리 경로
        
    Returns:
        (성공 여부, 메시지)
    """
    project_name = project_path.name
    
    if is_git_repo(project_path):
        # 이미 Git repository인 경우
        if has_gitignore(project_path):
            logger.info(f"[SKIP] '{project_name}' is already a git repository with .gitignore")
            return True, f"'{project_name}' is already initialized"
        else:
            # .gitignore 추가
            logger.info(f"[INFO] Adding .gitignore to existing git repository: '{project_name}'")
            gitignore_path = project_path / ".gitignore"
            gitignore_path.write_text(UNITY_GITIGNORE, encoding="utf-8")
            
            success, error = run_git_command(["add", ".gitignore"], project_path)
            if not success:
                return False, f"Failed to add .gitignore: {error}"
            
            success, error = run_git_command(["commit", "-m", "Add Unity .gitignore"], project_path)
            if not success:
                return False, f"Failed to commit .gitignore: {error}"
            
            logger.info(f"[DONE] .gitignore added and committed to '{project_name}'")
            return True, f"Added .gitignore to '{project_name}'"
    else:
        # 새로운 Git repository 초기화
        logger.info(f"[INFO] Initializing git repository: '{project_name}'")
        
        success, error = run_git_command(["init"], project_path)
        if not success:
            return False, f"Failed to initialize git: {error}"
        
        # .gitignore 생성
        logger.info(f"[INFO] Creating .gitignore: '{project_name}'")
        gitignore_path = project_path / ".gitignore"
        gitignore_path.write_text(UNITY_GITIGNORE, encoding="utf-8")
        
        # .gitignore 커밋
        success, error = run_git_command(["add", ".gitignore"], project_path)
        if not success:
            return False, f"Failed to add .gitignore: {error}"
        
        success, error = run_git_command(["commit", "-m", "Add Unity .gitignore"], project_path)
        if not success:
            return False, f"Failed to commit .gitignore: {error}"
        
        # 나머지 파일들 커밋
        logger.info(f"[INFO] Committing project files: '{project_name}'")
        success, error = run_git_command(["add", "."], project_path)
        if not success:
            return False, f"Failed to add files: {error}"
        
        success, error = run_git_command(["commit", "-m", "Initial commit"], project_path)
        if not success:
            return False, f"Failed to commit files: {error}"
        
        logger.info(f"[DONE] Git repository initialized: '{project_name}'")
        return True, f"Git repository initialized for '{project_name}'"


def clone_project(project_path: Path, output_path: Path, force: bool = False) -> Tuple[bool, str]:
    """
    프로젝트를 클론
    
    Args:
        project_path: 소스 프로젝트 디렉터리 경로
        output_path: 출력 경로 (클론될 위치)
        force: 기존 디렉터리가 있어도 강제로 클론할지 여부
        
    Returns:
        (성공 여부, 메시지)
    """
    project_name = project_path.name
    
    if not is_git_repo(project_path):
        return False, f"'{project_name}' is not a git repository"
    
    if output_path.exists():
        if not force:
            return False, f"Output path already exists: {output_path}\n  Use --force to overwrite"
        else:
            logger.warning(f"[WARNING] Removing existing directory: {output_path}")
            import shutil
            shutil.rmtree(output_path)
    
    # 출력 경로의 부모 디렉터리 생성
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    try:
        logger.info(f"[INFO] Cloning '{project_name}' to '{output_path}'")
        subprocess.run(
            ["git", "clone", str(project_path), str(output_path)],  # ✅ output_path 사용
            check=True,
            capture_output=True,
            text=True
        )
        logger.info(f"[DONE] Successfully cloned to '{output_path}'")
        return True, f"Successfully cloned to '{output_path}'"
    except subprocess.CalledProcessError as e:
        error_msg = e.stderr if e.stderr else str(e)
        return False, f"Failed to clone: {error_msg}"


# ============================================================================
# 메인 함수
# ============================================================================

def main():
    """메인 실행 함수"""
    args = parse_args()
    
    project_path = Path(args.project_path)
    output_path = Path(args.output_path)
    force = args.force
    
    # ========================================================================
    # 입력 검증
    # ========================================================================
    
    if not project_path.is_dir():
        logger.error(f"Project directory does not exist: {project_path}")
        sys.exit(1)
    
    logger.info("=" * 70)
    logger.info(f"Project Path:  {project_path}")
    logger.info(f"Output Path:   {output_path}")
    logger.info(f"Force Mode:    {'ON' if force else 'OFF'}")
    logger.info("=" * 70)
    
    # ========================================================================
    # Step 1: Git 초기화 및 .gitignore 설정
    # ========================================================================
    
    logger.info("\n[STEP 1] Initializing Git repository and setting up .gitignore...")
    logger.info("-" * 70)
    
    success, msg = init_and_commit_project(project_path)
    if not success:
        logger.error(f"Failed: {msg}")
        sys.exit(1)
    
    # ========================================================================
    # Step 2: 클론 수행
    # ========================================================================
    
    logger.info("\n[STEP 2] Cloning project to output path...")
    logger.info("-" * 70)
    
    success, msg = clone_project(project_path, output_path, force=force)
    if not success:
        logger.error(f"Failed: {msg}")
        sys.exit(1)
    
    # ========================================================================
    # 완료
    # ========================================================================
    
    logger.info("\n" + "=" * 70)
    logger.info("[SUCCESS] Project conversion and cloning completed successfully!")
    logger.info("=" * 70)


if __name__ == "__main__":
    main()

# cmd /v:on /c "set PROJ_NAME=NugetPlayground2&& python -m single_convert_unity_project --project_path "D:\1. Projects\1. Unity\!PROJ_NAME!" --output_path "E:\Unity\projects\!PROJ_NAME!""