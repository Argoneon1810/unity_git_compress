#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
관리할 유니티 프로젝트들이 들어 있는 디렉터리(Projects 디렉터리)와, 
출력(클론)할 디렉터리(Output 디렉터리), 그리고 블랙리스트 목록을 입력받아
각 프로젝트별로 순차적으로:
1) .gitignore 설정 및 Git 초기화
2) 최종적으로 Git Clone하여 Output 디렉터리에 복제

여러 프로젝트는 multiprocessing으로 병렬 처리됩니다.

Usage:
  python batch_convert_unity_projects.py --projects_dir "C:/UnityProjects" --output_dir "C:/Output" --blacklist "ProjectA,ProjectB" --workers 4
"""

import sys
import argparse
import subprocess
from pathlib import Path
from typing import List, Tuple
from multiprocessing import Pool, cpu_count
import logging


# ============================================================================
# 로깅 설정
# ============================================================================

def setup_logging() -> logging.Logger:
    """로깅 설정"""
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.INFO)
    
    handler = logging.StreamHandler()
    formatter = logging.Formatter('[%(levelname)s] %(message)s')
    handler.setFormatter(formatter)
    
    logger.addHandler(handler)
    return logger


logger = setup_logging()


# ============================================================================
# 상수
# ============================================================================

UNITY_GITIGNORE = r"""
# This .gitignore file should be placed at the root of your Unity project directory
#
# Get latest from https://github.com/github/gitignore/blob/main/Unity.gitignore
#
.utmp/
/[Ll]ibrary/
/[Tt]emp/
/[Oo]bj/
/[Bb]uild/
/[Bb]uilds/
/[Ll]ogs/
/[Uu]ser[Ss]ettings/
*.log

# By default unity supports Blender asset imports, *.blend1 blender files do not need to be commited to version control.
*.blend1
*.blend1.meta

# MemoryCaptures can get excessive in size.
# They also could contain extremely sensitive data
/[Mm]emoryCaptures/

# Recordings can get excessive in size
/[Rr]ecordings/

# Uncomment this line if you wish to ignore the asset store tools plugin
# /[Aa]ssets/AssetStoreTools*

# Autogenerated Jetbrains Rider plugin
/[Aa]ssets/Plugins/Editor/JetBrains*
# Jetbrains Rider personal-layer settings
*.DotSettings.user

# Visual Studio cache directory
.vs/

# Gradle cache directory
.gradle/

# Autogenerated VS/MD/Consulo solution and project files
ExportedObj/
.consulo/
*.csproj
*.unityproj
*.sln
*.suo
*.tmp
*.user
*.userprefs
*.pidb
*.booproj
*.svd
*.pdb
*.mdb
*.opendb
*.VC.db

# Unity3D generated meta files
*.pidb.meta
*.pdb.meta
*.mdb.meta

# Unity3D generated file on crash reports
sysinfo.txt

# Mono auto generated files
mono_crash.*

# Builds
*.apk
*.aab
*.unitypackage
*.unitypackage.meta
*.app

# Crashlytics generated file
crashlytics-build.properties

# TestRunner generated files
InitTestScene*.unity*

# Addressables default ignores, before user customizations
/ServerData
/[Aa]ssets/StreamingAssets/aa*
/[Aa]ssets/AddressableAssetsData/link.xml*
/[Aa]ssets/Addressables_Temp*
# By default, Addressables content builds will generate addressables_content_state.bin
# files in platform-specific subfolders, for example:
# /Assets/AddressableAssetsData/OSX/addressables_content_state.bin
/[Aa]ssets/AddressableAssetsData/*/*.bin*

# Visual Scripting auto-generated files
/[Aa]ssets/Unity.VisualScripting.Generated/VisualScripting.Flow/UnitOptions.db
/[Aa]ssets/Unity.VisualScripting.Generated/VisualScripting.Flow/UnitOptions.db.meta
/[Aa]ssets/Unity.VisualScripting.Generated/VisualScripting.Core/Property Providers
/[Aa]ssets/Unity.VisualScripting.Generated/VisualScripting.Core/Property Providers.meta

# Auto-generated scenes by play mode tests
/[Aa]ssets/[Ii]nit[Tt]est[Ss]cene*.unity*
"""


# ============================================================================
# 인자 파싱
# ============================================================================

def parse_args() -> argparse.Namespace:
    """커맨드 라인 인자 파싱"""
    parser = argparse.ArgumentParser(
        description="Manage multiple Unity projects with Git initialization and .gitignore (with multiprocessing support)."
    )
    parser.add_argument(
        "--projects_dir",
        required=True,
        help="Input directory where all the unity projects reside"
    )
    parser.add_argument(
        "--output_dir",
        required=True,
        help="Output directory where all the postprocessed projects will be saved"
    )
    parser.add_argument(
        "--blacklist",
        default="",
        help="Comma-separated list of project names to exclude from batch conversion"
    )
    parser.add_argument(
        "--workers",
        type=int,
        default=None,
        help=f"Number of worker processes (default: CPU count)"
    )
    return parser.parse_args()


# ============================================================================
# 유틸리티 함수
# ============================================================================

def is_git_repo(directory: Path) -> bool:
    """
    디렉터리가 Git repository인지 확인
    
    Args:
        directory: 확인할 디렉터리 경로
        
    Returns:
        Git repository이면 True, 아니면 False
    """
    git_dir = directory / ".git"
    return git_dir.is_dir()


def has_gitignore(directory: Path) -> bool:
    """
    디렉터리가 .gitignore 파일을 가지고 있는지 확인
    
    Args:
        directory: 확인할 디렉터리 경로
        
    Returns:
        .gitignore이 있으면 True, 아니면 False
    """
    gitignore_path = directory / ".gitignore"
    return gitignore_path.is_file()


def is_in_blacklist(project_name: str, blacklist_list: List[str]) -> bool:
    """
    프로젝트 이름이 블랙리스트에 포함되어 있는지 확인
    
    Args:
        project_name: 확인할 프로젝트 이름
        blacklist_list: 블랙리스트
        
    Returns:
        블랙리스트에 포함되면 True, 아니면 False
    """
    return any(project_name == item.strip() for item in blacklist_list)


def run_git_command(git_args: List[str], cwd: Path) -> Tuple[bool, str]:
    """
    Git 명령어 실행
    
    Args:
        git_args: git 서브명령어와 인자 리스트
        cwd: git 명령어를 실행할 디렉터리
        
    Returns:
        (성공 여부, 에러 메시지)
    """
    try:
        subprocess.run(
            ["git", "-C", str(cwd)] + git_args,
            check=True,
            capture_output=True,
            text=True
        )
        return True, ""
    except subprocess.CalledProcessError as e:
        error_msg = e.stderr if e.stderr else str(e)
        return False, error_msg


def init_and_commit_project(project_path: Path) -> Tuple[bool, str]:
    """
    프로젝트를 Git repository로 초기화하고 .gitignore 추가
    
    Args:
        project_path: 프로젝트 디렉터리 경로
        
    Returns:
        (성공 여부, 메시지)
    """
    project_name = project_path.name
    
    if is_git_repo(project_path):
        # 이미 Git repository인 경우
        if has_gitignore(project_path):
            return True, f"[SKIP] '{project_name}' → Already is git repository with .gitignore"
        else:
            # .gitignore 추가
            gitignore_path = project_path / ".gitignore"
            gitignore_path.write_text(UNITY_GITIGNORE, encoding="utf-8")
            
            success, error = run_git_command(["add", ".gitignore"], project_path)
            if not success:
                return False, f"Failed to add .gitignore: {error}"
            
            success, error = run_git_command(["commit", "-m", "Add Unity .gitignore"], project_path)
            if not success:
                return False, f"Failed to commit .gitignore: {error}"
            
            return True, f"[DONE] '{project_name}' → Added .gitignore to existing git repo"
    else:
        # 새로운 Git repository 초기화
        success, error = run_git_command(["init"], project_path)
        if not success:
            return False, f"Failed to initialize git: {error}"
        
        # .gitignore 생성
        gitignore_path = project_path / ".gitignore"
        gitignore_path.write_text(UNITY_GITIGNORE, encoding="utf-8")
        
        # .gitignore 커밋
        success, error = run_git_command(["add", ".gitignore"], project_path)
        if not success:
            return False, f"Failed to add .gitignore: {error}"
        
        success, error = run_git_command(["commit", "-m", "Add Unity .gitignore"], project_path)
        if not success:
            return False, f"Failed to commit .gitignore: {error}"
        
        # 나머지 파일들 커밋
        success, error = run_git_command(["add", "."], project_path)
        if not success:
            return False, f"Failed to add files: {error}"
        
        success, error = run_git_command(["commit", "-m", "Initial commit"], project_path)
        if not success:
            return False, f"Failed to commit files: {error}"
        
        return True, f"[DONE] '{project_name}' → Initialized as git repository"


def clone_project(project_path: Path, output_dir: Path) -> Tuple[bool, str]:
    """
    프로젝트를 클론
    
    Args:
        project_path: 소스 프로젝트 디렉터리 경로
        output_dir: 출력 디렉터리 경로
        
    Returns:
        (성공 여부, 메시지)
    """
    project_name = project_path.name
    clone_target = output_dir / project_name
    
    if not is_git_repo(project_path):
        return False, f"[SKIP] '{project_name}' → Not a git repository"
    
    if clone_target.exists():
        return False, f"[SKIP] '{project_name}' → Output folder already exists: {clone_target}"
    
    try:
        subprocess.run(
            ["git", "clone", str(project_path), str(clone_target)],
            check=True,
            capture_output=True,
            text=True
        )
        return True, f"[DONE] Cloned '{project_name}' → '{clone_target}'"
    except subprocess.CalledProcessError as e:
        error_msg = e.stderr if e.stderr else str(e)
        return False, f"Failed to clone: {error_msg}"


def process_single_project(args: Tuple[Path, Path, List[str]]) -> Tuple[str, bool]:
    """
    단일 프로젝트 처리 함수 (multiprocessing용)
    
    Git 초기화 및 커밋 → 클론을 연속으로 수행
    
    Args:
        args: (프로젝트_경로, 출력_디렉터리, 블랙리스트)
        
    Returns:
        (프로젝트_이름, 성공_여부)
    """
    project_path, output_dir, blacklist_list = args
    project_name = project_path.name
    
    # 블랙리스트 확인
    if is_in_blacklist(project_name, blacklist_list):
        logger.info(f"[SKIP] '{project_name}' is enlisted in the blacklist")
        return project_name, False
    
    # Step 1: Git 초기화 및 .gitignore 설정
    success, msg = init_and_commit_project(project_path)
    logger.info(msg)
    if not success:
        logger.error(f"[ERROR] '{project_name}' → {msg}")
        return project_name, False
    
    # Step 2: 클론 수행
    success, msg = clone_project(project_path, output_dir)
    logger.info(msg)
    if not success:
        logger.error(f"[ERROR] '{project_name}' → {msg}")
        return project_name, False
    
    return project_name, True


# ============================================================================
# 메인 함수
# ============================================================================

def main():
    """메인 실행 함수"""
    args = parse_args()
    
    projects_dir = Path(args.projects_dir)
    output_dir = Path(args.output_dir)
    blacklist_str = args.blacklist.strip()
    workers = args.workers or cpu_count()
    
    # 블랙리스트 파싱
    blacklist_list = [x for x in blacklist_str.split(",") if x.strip()] if blacklist_str else []
    
    # ========================================================================
    # 입력 검증
    # ========================================================================
    
    if not projects_dir.is_dir():
        logger.error(f"Projects Directory does not exist: {projects_dir}")
        sys.exit(1)
    
    # output_dir이 없으면 생성
    output_dir.mkdir(parents=True, exist_ok=True)
    
    logger.info(f"Projects Directory: {projects_dir}")
    logger.info(f"Output Directory: {output_dir}")
    logger.info(f"Blacklist: {blacklist_list if blacklist_list else 'None'}")
    logger.info(f"Workers: {workers}")
    logger.info("=" * 70)
    
    # ========================================================================
    # 처리할 프로젝트 목록 수집
    # ========================================================================
    
    projects_to_process = [
        p for p in projects_dir.iterdir()
        if p.is_dir() and not is_in_blacklist(p.name, blacklist_list)
    ]
    
    if not projects_to_process:
        logger.warning("No projects to process.")
        sys.exit(0)
    
    logger.info(f"Found {len(projects_to_process)} project(s) to process")
    logger.info("=" * 70)
    
    # ========================================================================
    # Multiprocessing으로 병렬 처리
    # ========================================================================
    
    # 각 프로젝트마다 (프로젝트_경로, 출력_디렉터리, 블랙리스트) 튜플 생성
    process_args = [
        (project_path, output_dir, blacklist_list)
        for project_path in projects_to_process
    ]
    
    with Pool(processes=workers) as pool:
        results = pool.map(process_single_project, process_args)
    
    # ========================================================================
    # 결과 요약
    # ========================================================================
    
    logger.info("=" * 70)
    successful = sum(1 for _, success in results if success)
    logger.info(f"Execution Complete: {successful}/{len(results)} projects processed successfully")
    logger.info("=" * 70)


if __name__ == "__main__":
    main()
